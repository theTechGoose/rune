//! Render command - outputs beautiful HTML for embedding .rune specs

use std::fs;
use std::path::Path;

use rune_parser::{parse_document, LineKind};

/// Render a .rune file to HTML
pub fn render(input: &Path, output: Option<&Path>) -> Result<(), String> {
    let source = fs::read_to_string(input)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let filename = input.file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("spec.rune");

    let html = render_to_html(&source, filename);

    match output {
        Some(path) => {
            fs::write(path, &html)
                .map_err(|e| format!("Failed to write output: {}", e))?;
            println!("Rendered to {}", path.display());
        }
        None => {
            println!("{}", html);
        }
    }

    Ok(())
}

fn render_to_html(source: &str, filename: &str) -> String {
    let parsed = parse_document(source);
    let lines: Vec<&str> = source.lines().collect();
    let line_count = lines.len();
    let _line_num_width = line_count.to_string().len();

    let mut html_lines = Vec::new();

    for (i, line) in lines.iter().enumerate() {
        let line_num = i + 1;
        let parsed_line = parsed.iter().find(|p| p.line_num == i);
        let highlighted = highlight_line(line, parsed_line.map(|p| &p.kind));

        html_lines.push(format!(
            r#"<div class="group/line flex hover:bg-white/[0.03] transition-all duration-150 rounded-sm -mx-1 px-1">
  <span class="select-none w-12 pr-4 text-right text-slate-600 text-xs leading-7 group-hover/line:text-slate-500 transition-colors font-mono">{num}</span>
  <span class="flex-1 leading-7">{content}</span>
</div>"#,
            num = line_num,
            content = if highlighted.is_empty() { "&nbsp;".to_string() } else { highlighted }
        ));
    }

    format!(r##"<!-- Rune Spec: {filename} -->
<!-- Generated by rune render - https://github.com/theTechGoose/rune -->
<script src="https://cdn.tailwindcss.com"></script>

<div class="not-prose my-8 font-mono">
  <!-- Outer glow container -->
  <div class="relative group">
    <!-- Ambient glow -->
    <div class="absolute -inset-1 bg-gradient-to-r from-cyan-500/20 via-transparent to-rose-500/10 rounded-3xl blur-2xl opacity-50 group-hover:opacity-75 transition-opacity duration-700"></div>

    <!-- Main card -->
    <div class="relative rounded-2xl bg-gradient-to-br from-[#0f1419] via-[#0d1117] to-[#0a0e14] shadow-2xl ring-1 ring-white/[0.08] overflow-hidden">

      <!-- Top highlight line -->
      <div class="h-px bg-gradient-to-r from-transparent via-cyan-400/30 to-transparent"></div>

      <!-- Header -->
      <div class="relative flex items-center gap-4 px-5 py-4 border-b border-white/[0.06]">
        <!-- Window dots -->
        <div class="flex items-center gap-2">
          <div class="w-3 h-3 rounded-full bg-[#ff5f57] shadow-lg shadow-red-500/20"></div>
          <div class="w-3 h-3 rounded-full bg-[#febc2e] shadow-lg shadow-yellow-500/20"></div>
          <div class="w-3 h-3 rounded-full bg-[#28c840] shadow-lg shadow-green-500/20"></div>
        </div>

        <!-- Filename -->
        <div class="flex items-center gap-2 ml-4">
          <span class="text-xl rune-icon">áš±</span>
          <span class="text-sm font-medium text-slate-300 tracking-wide">{filename}</span>
        </div>

        <!-- Copy button -->
        <button onclick="navigator.clipboard.writeText(this.closest('.not-prose').querySelector('code').innerText).then(() => {{ this.innerText = 'Copied!'; setTimeout(() => this.innerText = 'Copy', 1500) }})"
                class="ml-auto rounded-lg px-3 py-1.5 text-xs font-medium text-slate-400 bg-white/[0.03] ring-1 ring-white/[0.08] transition-all hover:bg-white/[0.06] hover:text-slate-300 hover:ring-white/[0.12] active:scale-95">
          Copy
        </button>
      </div>

      <!-- Code body -->
      <div class="relative p-5 overflow-x-auto">
        <pre class="text-[13px]"><code>{lines}</code></pre>
      </div>

      <!-- Bottom accent -->
      <div class="h-px bg-gradient-to-r from-transparent via-cyan-500/20 to-transparent"></div>
    </div>
  </div>
</div>

<style>
  /* Rune icon glow */
  .rune-icon {{
    color: #89babf;
    text-shadow: 0 0 20px rgba(137, 186, 191, 0.5);
    filter: drop-shadow(0 0 8px rgba(137, 186, 191, 0.3));
  }}

  /* Tag pills - glowing badges */
  .rune-tag {{
    color: #89babf;
    background: linear-gradient(135deg, rgba(137, 186, 191, 0.15) 0%, rgba(137, 186, 191, 0.08) 100%);
    padding: 2px 10px;
    border-radius: 6px;
    font-weight: 600;
    font-size: 0.85em;
    letter-spacing: 0.02em;
    box-shadow: 0 0 20px rgba(137, 186, 191, 0.15), inset 0 1px 0 rgba(255,255,255,0.08);
    border: 1px solid rgba(137, 186, 191, 0.2);
    text-shadow: 0 0 12px rgba(137, 186, 191, 0.5);
  }}

  /* Nouns - sage green */
  .rune-noun {{
    color: #8a9e7a;
    font-weight: 500;
  }}

  /* Verbs - dusty mauve */
  .rune-verb {{
    color: #9e8080;
  }}

  /* DTOs - moss green with subtle bg */
  .rune-dto {{
    color: #8fb86e;
    background: rgba(143, 184, 110, 0.1);
    padding: 1px 6px;
    border-radius: 4px;
    border: 1px solid rgba(143, 184, 110, 0.15);
  }}

  /* Builtins - cream */
  .rune-builtin {{
    color: #eeeeee;
  }}

  /* Boundary prefixes - rosewood, italic */
  .rune-boundary {{
    color: #b38585;
    font-style: italic;
    text-shadow: 0 0 15px rgba(179, 133, 133, 0.3);
  }}

  /* Faults - terracotta warning style */
  .rune-fault {{
    color: #c9826a;
    background: linear-gradient(135deg, rgba(201, 130, 106, 0.15) 0%, rgba(201, 130, 106, 0.08) 100%);
    padding: 1px 8px;
    border-radius: 4px;
    font-size: 0.9em;
    border: 1px solid rgba(201, 130, 106, 0.2);
    text-shadow: 0 0 10px rgba(201, 130, 106, 0.4);
  }}

  /* Comments - warm gray, subtle */
  .rune-comment {{
    color: #6b6360;
    font-style: italic;
  }}

  /* Punctuation */
  .rune-punct {{
    color: #4a4a4a;
  }}

  /* Parameters */
  .rune-param {{
    color: #a8b5c4;
  }}
</style>
"##,
        filename = html_escape(filename),
        lines = html_lines.join("\n"),
    )
}

fn highlight_line(line: &str, kind: Option<&LineKind>) -> String {
    let trimmed = line.trim();
    if trimmed.is_empty() {
        return String::new();
    }

    let indent = line.len() - line.trim_start().len();
    let indent_str = "&nbsp;".repeat(indent);

    match kind {
        Some(LineKind::Req { noun, verb, input, output, .. }) => {
            format!(
                r#"{}<span class="rune-tag">[REQ]</span> <span class="rune-noun">{}</span><span class="rune-punct">.</span><span class="rune-verb">{}</span><span class="rune-punct">(</span><span class="rune-dto">{}</span><span class="rune-punct">):</span> <span class="rune-dto">{}</span>"#,
                indent_str, html_escape(noun), html_escape(verb), html_escape(input), html_escape(output)
            )
        }
        Some(LineKind::Step { noun, verb, params, output, is_static, .. }) => {
            let sep = if *is_static { "::" } else { "." };
            let params_str = params.iter()
                .map(|p| format!(r#"<span class="rune-param">{}</span>"#, html_escape(p)))
                .collect::<Vec<_>>()
                .join(r#"<span class="rune-punct">, </span>"#);
            let output_html = if output.is_empty() {
                String::new()
            } else {
                format!(r#"<span class="rune-punct">:</span> <span class="rune-dto">{}</span>"#, html_escape(output))
            };
            format!(
                r#"{}<span class="rune-noun">{}</span><span class="rune-punct">{}</span><span class="rune-verb">{}</span><span class="rune-punct">(</span>{}<span class="rune-punct">)</span>{}"#,
                indent_str, html_escape(noun), sep, html_escape(verb), params_str, output_html
            )
        }
        Some(LineKind::BoundaryStep { prefix, noun, verb, params, output, is_static, .. }) => {
            let sep = if *is_static { "::" } else { "." };
            let params_str = params.iter()
                .map(|p| format!(r#"<span class="rune-param">{}</span>"#, html_escape(p)))
                .collect::<Vec<_>>()
                .join(r#"<span class="rune-punct">, </span>"#);
            let output_html = if output.is_empty() {
                String::new()
            } else {
                format!(r#"<span class="rune-punct">:</span> <span class="rune-builtin">{}</span>"#, html_escape(output))
            };
            format!(
                r#"{}<span class="rune-boundary">{}</span><span class="rune-noun">{}</span><span class="rune-punct">{}</span><span class="rune-verb">{}</span><span class="rune-punct">(</span>{}<span class="rune-punct">)</span>{}"#,
                indent_str, html_escape(prefix), html_escape(noun), sep, html_escape(verb), params_str, output_html
            )
        }
        Some(LineKind::Fault { names, .. }) => {
            let faults_html = names.iter()
                .map(|f| format!(r#"<span class="rune-fault">{}</span>"#, html_escape(f)))
                .collect::<Vec<_>>()
                .join(" ");
            format!("{}{}", indent_str, faults_html)
        }
        Some(LineKind::DtoDef { name, properties }) => {
            let props_str = properties.iter()
                .map(|p| format!(r#"<span class="rune-param">{}</span>"#, html_escape(p)))
                .collect::<Vec<_>>()
                .join(r#"<span class="rune-punct">, </span>"#);
            format!(
                r#"{}<span class="rune-tag">[DTO]</span> <span class="rune-dto">{}</span><span class="rune-punct">:</span> {}"#,
                indent_str, html_escape(name), props_str
            )
        }
        Some(LineKind::DtoDesc { text, .. }) => {
            format!(r#"{}<span class="rune-comment">{}</span>"#, indent_str, html_escape(text))
        }
        Some(LineKind::TypDef { name, type_name }) => {
            format!(
                r#"{}<span class="rune-tag">[TYP]</span> <span class="rune-noun">{}</span><span class="rune-punct">:</span> <span class="rune-builtin">{}</span>"#,
                indent_str, html_escape(name), html_escape(type_name)
            )
        }
        Some(LineKind::TypDesc { text, .. }) => {
            format!(r#"{}<span class="rune-comment">{}</span>"#, indent_str, html_escape(text))
        }
        Some(LineKind::Ply { noun, verb, params, output, is_static, .. }) => {
            let sep = if *is_static { "::" } else { "." };
            let params_str = params.iter()
                .map(|p| format!(r#"<span class="rune-param">{}</span>"#, html_escape(p)))
                .collect::<Vec<_>>()
                .join(r#"<span class="rune-punct">, </span>"#);
            let output_html = if output.is_empty() {
                String::new()
            } else {
                format!(r#"<span class="rune-punct">:</span> <span class="rune-dto">{}</span>"#, html_escape(output))
            };
            format!(
                r#"{}<span class="rune-tag">[PLY]</span> <span class="rune-noun">{}</span><span class="rune-punct">{}</span><span class="rune-verb">{}</span><span class="rune-punct">(</span>{}<span class="rune-punct">)</span>{}"#,
                indent_str, html_escape(noun), sep, html_escape(verb), params_str, output_html
            )
        }
        Some(LineKind::Cse { name, .. }) => {
            format!(
                r#"{}<span class="rune-tag">[CSE]</span> <span class="rune-noun">{}</span>"#,
                indent_str, html_escape(name)
            )
        }
        Some(LineKind::Ret { value, .. }) => {
            format!(
                r#"{}<span class="rune-tag">[RET]</span> <span class="rune-dto">{}</span>"#,
                indent_str, html_escape(value)
            )
        }
        Some(LineKind::Ctr { class_name, .. }) => {
            format!(
                r#"{}<span class="rune-tag">[CTR]</span> <span class="rune-noun">{}</span>"#,
                indent_str, html_escape(class_name)
            )
        }
        Some(LineKind::Comment { text, .. }) => {
            format!(r#"{}<span class="rune-comment">// {}</span>"#, indent_str, html_escape(text))
        }
        Some(LineKind::DtoRef(name)) => {
            format!(r#"{}<span class="rune-dto">{}</span>"#, indent_str, html_escape(name))
        }
        Some(LineKind::Empty) => String::new(),
        Some(LineKind::MultilineContinuation { .. }) => {
            // Just escape and show as-is
            format!("{}{}", indent_str, html_escape(trimmed))
        }
        _ => {
            // Unknown or unhandled - just escape
            format!("{}{}", indent_str, html_escape(trimmed))
        }
    }
}

fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}
